<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="iostrategies"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>I/O Strategies</title>

  <para>When working with NIO, the natural question we ask is how we're going
  to process a particullar NIO event, which occurred on an NIO channel.
  Usually we have two options: process the NIO event in the current (Selector)
  thread or pass it to the worker thread for processing.</para>

  <para><orderedlist>
      <listitem>
        <para><emphasis role="bold">Worker-thread
        IOStrategy</emphasis>.</para>

        <para>The most useful IOStrategy, where Selector thread delegates NIO
        events processing to a worker threads.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/workerthread-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is very scalable and safe. We can change the
        size of selector and worker thread pool as required and there is no
        risk that some problem, which may occur during the specific NIO event
        processing, will impact other Channels registered on the same
        Selector.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Same-thread IOStrategy</emphasis>.</para>

        <para>Potentially the most efficient IOStrategy. Unlike the
        worker-thread IOStrategy, the same-thread IOStrategy processes NIO
        events in the current thread, avoiding expensive <footnote>
            <para>some OSes do a great job optimizing the thread context
            switches, but we still suppose it as relatively expensive
            operation.</para>
          </footnote> thread context switches.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/samethread-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is still pretty scalable, because we can tune
        the selector thread pool size, but it does have drawbacks. Care needs
        to be taken that channel NIO event processing won't block or execute
        any long lasting operation, because it may block the processing of
        other NIO events that occur on the same Selector.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Dynamic IOStrategy</emphasis>.</para>

        <para>As mentioned previously worker-thread and same-thread strategies
        have distinct advantages and disadvantages. However, what if a
        strategy could try to swap them smartly during runtime depending on
        the current conditions (load, gathered statistics... etc)?</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/dynamic-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>Potentially this IOStrategy could bring a lot of benefit and
        allow finer control of the resources. However, it's important to not
        overload the condition evaluation logic, as its complexity will make
        this IOStrategy inefficient comparing to previous two
        strategies.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Leader-follower
        IOStrategy</emphasis>.</para>

        <para>The last IOStrategy included with Grizzly 2.0, is the
        leader-follower strategy:</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/leaderfollower-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is similar to worker-thread IOStrategy, but
        instead of passing NIO event processing to a worker thread, it changes
        worker thread to a selector thread by passing it the control over
        Selector and the actual NIO event processing takes place in the
        current thread.</para>
      </listitem>
    </orderedlist></para>

  <para>Grizzly 2.0 provides general interface <emphasis
  role="italic">org.glassfish.grizzly.IOStrategy:</emphasis></para>

  <programlisting language="java">public interface Strategy { 
    boolean executeIoEvent(Connection connection, IOEvent ioEvent) 
    throws IOException; 
}</programlisting>

  <para>And the IOStrategy implementation may decide what to do with the
  specific NIO event processing.</para>

  <para>Grizzly 2.0 has four predefined IOStrategy implementations, as per
  list above:</para>

  <para><orderedlist>
      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.WorkerThreadIOStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.SameThreadIOStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.SimpleDynamicThreadStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.LeaderFollowerIOStrategy</emphasis></para>
      </listitem>
    </orderedlist></para>

  <para>The strategies are assigned per Transport, so it's possible to get/set
  the IOStrategy using Transport's <emphasis
  role="italic">get/setStrategy</emphasis> methods. By default TCP and UDP
  transports use the worker-thread IOStrategy.</para>
</section>
