<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<section version="5.0" xml:id="iostrategies"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>I/O Strategies</title>

  <para>When working with NIO, the natural question we ask is how we're going
  to process a particullar NIO event, which occurred on an NIO channel.
  Usually we have two options: process the NIO event in the current (Selector)
  thread or pass it to the worker thread for processing.</para>

  <para><orderedlist>
      <listitem>
        <para><emphasis role="bold">Worker-thread
        IOStrategy</emphasis>.</para>

        <para>The most useful IOStrategy, where Selector thread delegates NIO
        events processing to a worker threads.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/workerthread-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is very scalable and safe. We can change the
        size of selector and worker thread pool as required and there is no
        risk that some problem, which may occur during the specific NIO event
        processing, will impact other Channels registered on the same
        Selector.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Same-thread IOStrategy</emphasis>.</para>

        <para>Potentially the most efficient IOStrategy. Unlike the
        worker-thread IOStrategy, the same-thread IOStrategy processes NIO
        events in the current thread, avoiding expensive <footnote>
            <para>some OSes do a great job optimizing the thread context
            switches, but we still suppose it as relatively expensive
            operation.</para>
          </footnote> thread context switches.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/samethread-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is still pretty scalable, because we can tune
        the selector thread pool size, but it does have drawbacks. Care needs
        to be taken that channel NIO event processing won't block or execute
        any long lasting operation, because it may block the processing of
        other NIO events that occur on the same Selector.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Dynamic IOStrategy</emphasis>.</para>

        <para>As mentioned previously worker-thread and same-thread strategies
        have distinct advantages and disadvantages. However, what if a
        strategy could try to swap them smartly during runtime depending on
        the current conditions (load, gathered statistics... etc)?</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/dynamic-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>Potentially this IOStrategy could bring a lot of benefit and
        allow finer control of the resources. However, it's important to not
        overload the condition evaluation logic, as its complexity will make
        this IOStrategy inefficient comparing to previous two
        strategies.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Leader-follower
        IOStrategy</emphasis>.</para>

        <para>The last IOStrategy included with Grizzly 2.0, is the
        leader-follower strategy:</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/leaderfollower-strategy.gif"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>This IOStrategy is similar to worker-thread IOStrategy, but
        instead of passing NIO event processing to a worker thread, it changes
        worker thread to a selector thread by passing it the control over
        Selector and the actual NIO event processing takes place in the
        current thread.</para>
      </listitem>
    </orderedlist></para>

  <para>Grizzly 2.0 provides general interface <emphasis
  role="italic">org.glassfish.grizzly.IOStrategy:</emphasis></para>

  <programlisting language="java">/**
 * &lt;tt&gt;strategy&lt;/tt&gt; is responsible for making decision how
 * {@link Runnable} task will be run: in current thread, worker thread.
 *
 * &lt;tt&gt;strategy&lt;/tt&gt; can make any other processing decisions.
 * 
 * @author Alexey Stashok
 */
public interface IOStrategy extends WorkerThreadPoolConfigProducer {

    /**
     * The {@link org.glassfish.grizzly.nio.SelectorRunner} will invoke this
     * method to allow the strategy implementation to decide how the
     * {@link IOEvent} will be handled.
     *
     * @param connection the {@link Connection} upon which the provided
     *  {@link IOEvent} occurred.
     * @param ioEvent the {@link IOEvent} that triggered execution of this
     *  &lt;code&gt;strategy&lt;/code&gt;
     *
     * @return &lt;tt&gt;true&lt;/tt&gt;, if this thread should keep processing IOEvents on
     * the current and other Connections, or &lt;tt&gt;false&lt;/tt&gt; if this thread
     * should hand-off the farther IOEvent processing on any Connections,
     * which means IOStrategy is becoming responsible for continuing IOEvent
     * processing (possibly starting new thread, which will handle IOEvents).
     *
     * @throws IOException if an error occurs processing the {@link IOEvent}.
     */
    boolean executeIoEvent(final Connection connection, final IOEvent ioEvent)
    throws IOException;

}</programlisting>

  <para>And the IOStrategy implementation may decide what to do with the
  specific NIO event processing.</para>

  <para>Grizzly 2.0 has four predefined IOStrategy implementations, as per
  list above:</para>

  <para><orderedlist>
      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.WorkerThreadIOStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.SameThreadIOStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.SimpleDynamicThreadStrategy</emphasis></para>
      </listitem>

      <listitem>
        <para><emphasis
        role="italic">org.glassfish.grizzly.strategies.LeaderFollowerIOStrategy</emphasis></para>
      </listitem>
    </orderedlist></para>

  <para>The strategies are assigned per Transport, so it's possible to get/set
  the IOStrategy using Transport's <emphasis
  role="italic">get/setStrategy</emphasis> methods. By default TCP and UDP
  transports use the worker-thread IOStrategy.</para>
</section>
