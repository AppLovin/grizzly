<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter xml:id="http-server-framework" version="5.0"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>The HTTP Server Framework</title>

  <section xml:id="hsf-overview">
    <title>Overview</title>

    <para>The Grizzly HTTP server framework builds off the HTTP codec
    framework to provide a more useful abstraction for day-to-day work. At a
    high level, this framework includes the following:</para>

    <itemizedlist>
      <listitem>
        <para>A simple server API for easy embedding of Grizzly within an
        application.</para>
      </listitem>

      <listitem>
        <para>Similar abstractions to those offered by the Servlet
        specification: HttpHandler (Servlet), Request (HttpServletRequest),
        Response (HttpServletResponse).</para>
      </listitem>

      <listitem>
        <para>The ability to deal with long running HTTP transactions via
        response suspend/resume facilities.</para>
      </listitem>

      <listitem>
        <para>Support of non-blocking IO streams (inbound and
        outbound).</para>
      </listitem>

      <listitem>
        <para>A file cache for static content.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section xml:id="hsf-building-simple">
    <title>Building a Simple Web Server</title>

    <section xml:id="hsf-building-simple-components">
      <title>Components of the Framework</title>

      <para>This section will cover the major components of this
      framework.</para>

      <table>
        <title>HTTP Server Components</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry>HttpServer</entry>

              <entry>This is the Grizzly HTTP server which can be used to
              create standalong HTTP programs or embed Grizzly within other
              application to provide HTTP services.</entry>
            </row>

            <row>
              <entry>ServerConfiguration</entry>

              <entry>This class allows developer to add custom HttpHandler
              implementations to the server as well as exposing JMX/monitoring
              features.</entry>
            </row>

            <row>
              <entry>NetworkListener</entry>

              <entry>This is an abstraction of the Grizzly NIOTransport and
              Filter implementations. It also allows the enabling/disabling of
              HTTP-related features such as keep-alive, chunked
              transfer-encoding, cusom addons etc. HttpServer can support
              multiple NetworkListeners. Also, keep in mind that all
              HttpHandlers added to the ServerConfiguration will be shared
              across all listeners.</entry>
            </row>

            <row>
              <entry>HttpHandler</entry>

              <entry>HttpHandler is akin to javax.servlet.Servlet.</entry>
            </row>

            <row>
              <entry>Request</entry>

              <entry>Request is similar to
              javax.servlet.http.HttpServletRequest</entry>
            </row>

            <row>
              <entry>Response</entry>

              <entry>Request is similar to
              javax.servlet.http.HttpServletResponse</entry>
            </row>

            <row>
              <entry>Session</entry>

              <entry>Session is similar to
              javax.servlet.http.HttpSession</entry>
            </row>

            <row>
              <entry>HttpServerFilter</entry>

              <entry>This Filter implementation provides the high-level HTTP
              request/response processing. Note: This Filter is automatically
              added to the FilterChain used by the NetworkListener, but if a
              custom chain as well as this level of HTTP processsing, this
              Filter will need to be added to the chain.</entry>
            </row>

            <row>
              <entry>FileCacheFilter</entry>

              <entry>This Filter provides static resource caching capabilites.
              Like the HttpServerFilter, if file caching is enabled, this
              Filter will be added automatically.</entry>
            </row>

            <row>
              <entry>AddOn</entry>

              <entry>The general interface for HttpServer addons, which
              suppose to extend basic HttpServer functionality.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section xml:id="hsf-quickstart">
      <title>Quick Start</title>

      <para>To get started with the HTTP server framework you'll need to
      include the module in your project:</para>

      <programlisting language="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.glassfish.grizzly&lt;/groupId&gt;
        &lt;artifactId&gt;grizzly-http-server&lt;/artifactId&gt;
        &lt;version&gt;@project.version@&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>

      <para>Once the dependencies are in place, the absolute simplest, albeit
      not-very-useful, server one can create is:</para>

      <programlisting language="java">HttpServer server = HttpServer.createSimpleServer();
try {
    server.start();
    System.out.println("Press any key to stop the server...");
    System.in.read();
} catch (Exception e) {
    System.err.println(e);
}</programlisting>

      <para>This will create a Grizzly HTTP server listening on 0.0.0.0:8080
      and will serve content from the directory in which the JVM was started.
      As stated before, while this demonstrates the ease of embedding Grizzly,
      it's not very useful.</para>

      <para>Let's add a HttpHandler to server the current time.</para>

      <programlisting language="java" linenumbering="numbered">HttpServer server = HttpServer.createSimpleServer();
server.getServerConfiguration().addHttpHandler(
    new HttpHandler() {
        public void service(Request request, Response response) throws Exception {
            final SimpleDateFormat format = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
            final String date = format.format(new Date(System.currentTimeMillis()));
            response.setContentType("text/plain");
            response.setContentLength(date.length());
            response.getWriter().write(date);
        }
    },
    "/time");
try {
    server.start();
    System.out.println("Press any key to stop the server...");
    System.in.read();
} catch (Exception e) {
    System.err.println(e);
}</programlisting>

      <para>Line 2 adds a new HttpHandler (think Servlet) to service requests
      make to /time. Any other requests to the server will be considered
      requests for static content served from the direction in which the JVM
      was started.</para>
    </section>
  </section>

  <section xml:id="hsf-configuration">
    <title>HTTP Server Configuration</title>

    <table>
      <title>ServerConfiguration Properties</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>name</entry>

            <entry>Set the name of this HttpServer instance. If no name is
            defined, one will be assigned.</entry>
          </row>

          <row>
            <entry>jmxEnabled</entry>

            <entry>Determines whether or not JMX monitoring will be enabled
            for this HttpServer instance. This property can be changed at
            runtime.</entry>
          </row>

          <row>
            <entry>version</entry>

            <entry>Set the version of this server instance. If not explicitly
            set, the version will be @project.version@.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>In addition to the properties described above, the
    ServerConfiguration allows the addition (addHttpHandler()), removal
    (removeHttpHandler(), and listing of (getHttpHandlers())
    HttpHandlers.</para>

    <table>
      <title>NetworkListener Properties</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>name</entry>

            <entry>The logical name of this listener (settable only by
            constructor).</entry>
          </row>

          <row>
            <entry>host</entry>

            <entry>The network host to which this listener will bind. If not
            user specified, it will bind to 0.0.0.0 (settable only by
            constructor).</entry>
          </row>

          <row>
            <entry>port</entry>

            <entry>The network port to which this listener will bind. If not
            user specified, it will bind to port 8080 (settable only by
            constructor).</entry>
          </row>

          <row>
            <entry>keepAlive</entry>

            <entry>Returns the keep-alive configuration for this listener.
            This allows configuration for connection idle timeout (default of
            30 seconds) and max keep-alive (default of 256) requests
            configuration.</entry>
          </row>

          <row>
            <entry>transport</entry>

            <entry>This property will typically be used for fine tuning the
            transport configuration, however, custom transports can also be
            provided.</entry>
          </row>

          <row>
            <entry>addons</entry>

            <entry>The set of addons, which suppose to extend basic HttpServer
            functionality.</entry>
          </row>

          <row>
            <entry>chunkingEnabled</entry>

            <entry>Enable/disable the chunk transfer-encoding (defaults to
            enabled).</entry>
          </row>

          <row>
            <entry>secure</entry>

            <entry>Enable/disable SSL/TLS support (defaults to
            disabled)</entry>
          </row>

          <row>
            <entry>sslEngineConfig</entry>

            <entry>If SSL/TLS is enabled, an SSLEngineConfigurator will need
            to be specified by the developer. This controls how the SSLEngine
            will be created.</entry>
          </row>

          <row>
            <entry>maxHttpHeaderSize</entry>

            <entry>Specifies, in bytes, the maximum size an http message
            header may be before being rejected. This configuration is only
            applicable to incoming requests.</entry>
          </row>

          <row>
            <entry>filterChain</entry>

            <entry>Allows customization of the FilterChain used by this
            listener instance.</entry>
          </row>

          <row>
            <entry>fileCache</entry>

            <entry>Allows customization of the FileCache configuration used by
            this listener instance.</entry>
          </row>

          <row>
            <entry>contentEncodings</entry>

            <entry>The content encodings (gzip as an example) that may be
            applied for HTTP transactions on this listener. Custom encodings
            may be provided.</entry>
          </row>

          <row>
            <entry>maxPendingBytes</entry>

            <entry>Specifies the maximum number of bytes that may be pending
            to be written to a particular connection. If bytes aren't being
            consumed and this value is exceeded, the connection will be
            closed.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section xml:id="hsf-suspend-resume">
    <title>Long-lasting HTTP requests (suspend/response)</title>

    <para>Some HTTP interactions may need to trigger a long running
    transaction on the server and wait for the result to generate a response.
    However, this can be problematic with an NIO-based server as there are
    generally a handful of threads servicing all requests. A long running
    transaction in this case would tie up one of the processing threads
    preventing it from servicing other requests. If enough of these long
    running transactions were initiated, it could lead to a denial of
    service.</para>

    <para>To support these use cases without negatively impacting the server,
    Grizzly allows a response to be suspended until such time that the long
    running task is complete and the response is ready to be generated.</para>

    <para>Let's cover the methods related to response suspend/resume. The
    following methods are available on the Response object itself:</para>

    <programlisting language="java">    /**
     * Suspend the {@link Response}. Suspending a {@link Response} will
     * tell the underlying container to avoid recycling objects associated with
     * the current instance, and also to avoid committing response.
     */
    public void suspend() {
        ...
    }

    /**
     * Suspend the {@link Response}. Suspending a {@link Response} will
     * tell the underlying container to avoid recycling objects associated with
     * the current instance, and also to avoid committing response.
     *
     * @param timeout The maximum amount of time,
     * a {@link Response} can be suspended. When the timeout expires (because
     * nothing has been written or because the {@link Response#resume()}
     * or {@link Response#cancel()}), the {@link Response} will be automatically
     * resumed and committed. Usage of any methods of a {@link Response} that
     * times out will throw an {@link IllegalStateException}.
     * @param timeunit timeout units
     *
     */
    public void suspend(final long timeout, final TimeUnit timeunit) {
        ...
    }

    /**
     * Suspend the {@link Response}. Suspending a {@link Response} will
     * tell the underlying container to avoid recycling objects associated with
     * the current instance, and also to avoid committing response. When the
     * {@link Response#resume()} is invoked, the container will
     * make sure {@link CompletionHandler#completed(Object)}
     * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;. When the
     * {@link Response#cancel()} is invoked, the container will
     * make sure {@link org.glassfish.grizzly.CompletionHandler#cancelled()}
     * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;. If the timeout expires, the
     * {@link org.glassfish.grizzly.CompletionHandler#cancelled()} is invoked with 
     * the original &lt;tt&gt;attachment&lt;/tt&gt; and the {@link Response} committed.
     *
     * @param timeout The maximum amount of time the {@link Response} can be suspended.
     * When the timeout expires (because nothing has been written or because the
     * {@link Response#resume()} or {@link Response#cancel()}), the {@link Response}
     * will be automatically resumed and committed. Usage of any methods of a
     * {@link Response} that times out will throw an {@link IllegalStateException}.
     * @param timeunit timeout units
     * @param completionHandler a {@link org.glassfish.grizzly.CompletionHandler}
     */
    public void suspend(final long timeout, 
                        final TimeUnit timeunit,
                        final CompletionHandler&lt;Response&gt; completionHandler) {
        ...
    }

    /**
     * Suspend the {@link Response}. Suspending a {@link Response} will
     * tell the underlying container to avoid recycling objects associated with
     * the current instance, and also to avoid committing response. When the
     * {@link Response#resume()} is invoked, the container will
     * make sure {@link CompletionHandler#completed(Object)}
     * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;. When the
     * {@link Response#cancel()} is invoked, the container will
     * make sure {@link org.glassfish.grizzly.CompletionHandler#cancelled()}
     * is invoked with the original &lt;tt&gt;attachment&lt;/tt&gt;. If the timeout expires, the
     * {@link org.glassfish.grizzly.CompletionHandler#cancelled()} is invoked with the 
     * original &lt;tt&gt;attachment&lt;/tt&gt; and the {@link Response} committed.
     *
     * @param timeout The maximum amount of time the {@link Response} can be suspended.
     * When the timeout expires (because nothing has been written or because the
     * {@link Response#resume()} or {@link Response#cancel()}), the {@link Response}
     * will be automatically resumed and committed. Usage of any methods of a
     * {@link Response} that times out will throw an {@link IllegalStateException}.
     * @param timeunit timeou
     * @param completionHandler a {@link org.glassfish.grizzly.CompletionHandler}
     * @param timeoutHandler {@link TimeoutHandler} to customize the suspended 
     *  &lt;tt&gt;Response&lt;/tt&gt; timeout logic.
     */
    public void suspend(final long timeout, 
                        final TimeUnit timeunit,
                        final CompletionHandler&lt;Response&gt; completionHandler,
                        final TimeoutHandler timeoutHandler) {
        ...
    }

    /**
     * Complete the {@link Response} and finish/commit it. If a
     * {@link CompletionHandler} has been defined, its 
     * {@link CompletionHandler#completed(Object)} will first be invoked, 
     * then the {@link Response#finish()}.
     * Those operations commit the response.
     */
    public void resume() {
        ...
    }

    /**
     * Cancel the {@link Response} and finish/commit it. If a
     * {@link CompletionHandler} has been defined, its 
     * {@link CompletionHandler#cancelled()} will first be invoked, 
     * then the {@link Response#finish()}.
     * Those operations commit the response.
     */
    public void cancel() {
        ...
    }

    /**
     * Get the context of the suspended &lt;tt&gt;Response&lt;/tt&gt;.
     *
     * @return the context of the suspended &lt;tt&gt;Response&lt;/tt&gt;.
     */
    public SuspendContext getSuspendContext() {
        ...
    }
    
    /**
     * Return &lt;tt&gt;true&lt;//tt&gt; if that {@link Response#suspend()} has been
     * invoked and set to &lt;tt&gt;true&lt;/tt&gt;
     * @return &lt;tt&gt;true&lt;//tt&gt; if that {@link Response#suspend()} has been
     * invoked and set to &lt;tt&gt;true&lt;/tt&gt;
     */
    public boolean isSuspended() {
        ...
    }</programlisting>

    <para>The following diagram describes a typical suspend/resume
    scenario:</para>

    <figure>
      <title>Suspend/Resume</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/httpserverframework/susres.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The "Suspended Response Queue" warrants some explaination. If a
    suspended Response has defined a timeout, it will be added to the
    "Suspended Response Queue". When the queue is processed, the current time
    will be evaluated against the timeout as defined within the Response's
    SuspendContext. If the timeout has been exceeded, the response will be
    committed and the Response object within the queue will be marked for
    removal. So in the case no timeout has been defined, the response will not
    be added to the queue, and the task may run indefiniately.</para>
  </section>

  <section xml:id="hsf-nio-streams">
    <title>NIO Streams</title>

    <para>In Grizzly 1.9, it was possible to write data to the client using
    non-blocking I/O, however, when reading post data from within a
    GrizzlyAdapter implementation, all I/O in that case was blocking. In
    Grizzly @project.version@, it's very simple using the InputStream/Reader from the
    request and read data in a non-blocking manner. As far as writing, all I/O
    will be written in non-blocking mode, but there is some extra features on
    the OutputStream vended by the Response instance that will be covered that
    expose advanced non-blocking operations.</para>

    <section xml:id="hsf-nio-streams-non-blocking">
      <title>Non-Blocking Writing</title>

      <para>The methods getOutputStream() and getWriter() on Response return
      instances of NIOOutputStream and NIOWriter. In addition to the methods
      defined by java.io.OutputStream and java.io.Writer, these entities both
      implement the NIOOutputSink interface.</para>

      <programlisting language="java">/**
 * &lt;p&gt;
 * This interface defines methods to allow an {@link java.io.OutputStream} or
 * {@link java.io.Writer} to allow the developer to check with the runtime
 * whether or not it's possible to write a certain amount of data, or if it's
 * not possible, to be notified when it is.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public interface NIOOutputSink {


    /**
     * Instructs the &lt;code&gt;NIOOutputSink&lt;/code&gt; to invoke the provided
     * {@link WriteHandler} when it is possible to write &lt;code&gt;length&lt;/code&gt;
     * bytes.
     *
     * Note that once the {@link WriteHandler} has been notified, it will not
     * be considered for notification again at a later point in time. 
     *
     * @param handler the {@link WriteHandler} that should be notified
     *  when it's possible to write &lt;code&gt;length&lt;/code&gt; bytes.
     * @param length the number of bytes that require writing.
     *
     * @throws IllegalStateException if this method is invoked and a handler
     *  from a previous invocation is still present (due to not having yet been
     *  notified).  
     */
    void notifyCanWrite(final WriteHandler handler, final int length);


    /**
     * @param length specifies the number of bytes that require writing
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a write to this &lt;code&gt;NIOOutputSink&lt;/code&gt;
     *  will succeed, otherwise returns &lt;code&gt;false&lt;/code&gt;.
     */
    boolean canWrite(final int length);

}</programlisting>

      <para>The typical flow when using these methods is to call canWrite()
      with the desired length. Whether or not the desired amount of data will
      depened, primarily, on the configuration value of maxPendingWrites
      property on the NetworkListener being used to process the current
      request.</para>

      <para>For example, if the client is on a slow connection, and the OS
      network buffer is full, the write queue maintained by the Transport
      implementation would start to full up. If an attempt to write is made
      that will exeed the queue limit, a
      PendingWriteQueueLimitExceededException will be thrown. However, if the
      developer calls canWrite() with the desired length, and the return value
      is false, then it is know there, that the write would fail. This
      condition can be gracefully be handled by calling notifyCanWrite()
      providing a WriteHandler and the desired length. Once the pending write
      queue drains enough to support the length, the WriteHandler will be
      notified to allow the developer to continue sending content to the
      client.</para>

      <para>For Grizzly @project.version@ HTTP applications that deal in primarily binary
      data and are using Grizzly Buffers, they can leverage an additional
      method available on the NIOOutputStream specified by the
      BinaryNIOutputSink interface. This interface allows the direct writing
      of Buffer instances. This optimizes away the need to copy bytes to a
      Buffer implementation under the covers.</para>

      <programlisting language="java">/**
 * Adds the ability for binary based {@link NIOOutputSink}s to write a 
 * {@link Buffer} instead of having to convert to those types supported by
 * {@link java.io.OutputStream}.
 *
 * @since 2.0
 */
public interface BinaryNIOOutputSink extends NIOOutputSink {

    /**
     * Writes the contents of the specified {@link org.glassfish.grizzly.Buffer}.
     *
     * @param buffer the {@link org.glassfish.grizzly.Buffer to write}
     */
    void write(final Buffer buffer) throws IOException;
    
}</programlisting>
    </section>

    <section xml:id="hsf-nio-streams-non-blocking-reading">
      <title>Non-Blocking Reading</title>

      <para>On the input, side, Grizzly provides a similar interface for
      non-blocking reads called NIOInputSource.</para>

      <programlisting language="java">/**
 * &lt;p&gt;
 * This interface defines methods to allow an {@link InputStream} or
 * {@link Reader} to notify the developer &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how much&lt;/em&gt;
 * data is ready to be read without blocking.
 * &lt;/p&gt;
 *
 * @since 2.0
 */
public interface NIOInputSource {


    /**
     * &lt;p&gt;
     * Notify the specified {@link ReadHandler} when any number of bytes
     * can be read without blocking.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Invoking this method is equivalent to calling: notifyAvailable(handler, 0).
     * &lt;/p&gt;
     *
     * @param handler the {@link ReadHandler} to notify.
     *
     * @throws IllegalArgumentException if &lt;code&gt;handler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *  or if &lt;code&gt;size&lt;/code&gt; is less than zero.
     * @throws IllegalStateException if an attempt is made to register a handler
     *  before an existing registered handler has been invoked or if all request
     *  data has already been read.
     *
     * @see ReadHandler#onDataAvailable()
     * @see ReadHandler#onAllDataRead()
     */
    void notifyAvailable(final ReadHandler handler);


    /**
     * &lt;p&gt;
     * Notify the specified {@link ReadHandler} when the number of bytes that
     * can be read without blocking is greater or equal to the specified
     * &lt;code&gt;size&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param handler the {@link ReadHandler} to notify.
     * @param size the least number of bytes that must be available before
     *  the {@link ReadHandler} is invoked.  If size is &lt;code&gt;0&lt;/code&gt;, the
     *  handler will be notified as soon as data is available no matter the
     *  size.
     *
     * @throws IllegalArgumentException if &lt;code&gt;handler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *  or if &lt;code&gt;size&lt;/code&gt; is less than zero.
     * @throws IllegalStateException if an attempt is made to register a handler
     *  before an existing registered handler has been invoked or if all request
     *  data has already been read.
     *
     * @see ReadHandler#onDataAvailable()
     * @see ReadHandler#onAllDataRead()
     */
    void notifyAvailable(final ReadHandler handler, final int size);


    /**
     * @return &lt;code&gt;true&lt;/code&gt; when all data for this particular request
     *  has been read, otherwise returns &lt;code&gt;false&lt;/code&gt;.
     */
    boolean isFinished();


    /**
     * @return the number of bytes (or characters) that may be obtained
     *  without blocking.  Note when dealing with characters, this method
     *  will return an estimate on the number of characters available. 
     */
    int readyData();


    /**
     * @return &lt;code&gt;true&lt;/code&gt; if data can be obtained without blocking,
     *  otherwise returns &lt;code&gt;false&lt;/code&gt;.
     */
    boolean isReady();

}</programlisting>

      <para>The general idea behind non-blocking writes holds true for
      non-blocking reads. The developer can check to see if data is available
      to be read without blocking by calling isReady() or checking for a
      non-zero return from readyData(). If no data can be read without
      blocking, use notifyAvailable(ReadHandler) or
      notifyAvailable(ReadHandler, int). When data is becomes available, the
      ReadHandler will be invoked. Note that if no length is provided to the
      notifyAvailable() methods, the ReadHandler will be invoked as soon as
      any data becomes available. In this case, it's a good idea to check how
      much can be read by another call to readyData().</para>

      <para>For optimized reading of binary data, there is the specialized
      interface, BinaryNIOInputSource, that allows direct access to the Buffer
      used to store the incoming data:</para>

      <programlisting language="java">/**
 * Adds the ability for binary based {@link NIOInputSource}s to obtain the
 * incoming {@link org.glassfish.grizzly.Buffer} directly without having to
 * use intermediate objects to copy the data to.
 *
 * @since 2.0
 */
public interface BinaryNIOInputSource extends NIOInputSource {

    /**
     * &lt;p&gt;
     * Returns the underlying {@link org.glassfish.grizzly.Buffer} that backs this
     *  &lt;code&gt;NIOInputSource&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @return the underlying {@link org.glassfish.grizzly.Buffer} that backs this
     *  &lt;code&gt;NIOInputSource&lt;/code&gt;.
     */
    Buffer getBuffer();

}</programlisting>

      <para>One final word on NIOInputSource implementations with respect to
      the Request object. In order for these methods to function properly,
      developers must obtain the desired NIOInputSource by calling
      Request.getInputStream(false) or Request.getReader(false). Specifiy a
      value of false sets the NIOInputSources to work in non-blocking mode. If
      the a value of true is provided to the getRead() or getInputStream()
      methods, the NIOInputSource will be set to blocking mode. It's not
      possible to change the mode after the initial invocations of these
      methods.</para>
    </section>
  </section>

  <section xml:id="hsf-filecache">
    <title>File Cache</title>

    <para>The FileCache allows for efficient caching of static content. There
    are several configuration options that allow fine tuning of each FileCache
    instance:</para>

    <table>
      <title>FileCache Configuration Properties</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>secondsMaxAge</entry>

            <entry>Specifies how long an resource may exist within the cache.
            If the value is zero or less, the resource may be cached
            indefinately. If not specified, the value defaults to -1.</entry>
          </row>

          <row>
            <entry>maxCacheEntries</entry>

            <entry>Specified how many resources may be cached. An attempt to
            add an entry that causes the max number of entries to be exceeded,
            the resource will be removed from the cache. The default number of
            cached entries is 1024.</entry>
          </row>

          <row>
            <entry>minEntrySize</entry>

            <entry>The maximum size, in bytes, a file must be in order to be
            cached in the heap cache. This defaults to Long.MIN_VALUE.</entry>
          </row>

          <row>
            <entry>maxEntrySize</entry>

            <entry>The maximum size, in bytes, a resource may be before it can
            no longer be considered cachable. This defaults to
            Long.MAX_VALUE.</entry>
          </row>

          <row>
            <entry>maxLargeFileCacheSize</entry>

            <entry>The maximum size, in bytes, of the memory mapped cache for
            large files. This defaults to Long.MAX_VALUE.</entry>
          </row>

          <row>
            <entry>maxSmallFileCacheSize</entry>

            <entry>The maximum size, in bytes, a file must be in order to be
            cached in the heap cachevs the mapped memory cache. This defaults
            to 1048576.</entry>
          </row>

          <row>
            <entry>enabled</entry>

            <entry>Whether or not the FileCache is enabled. This defaults to
            true on new NetworkListener instances.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>All properties of the FileCache can be manipulated by obtaining the
    FileCache instance by calling NetworkListener.getFileCache().</para>
  </section>

  <section xml:id="hsf-addons">
    <title>AddOn</title>

    <para>The AddOn abstraction provides a simple and generic way how to
    extend existing HttpServer functionality. The interface looks very
    simple:</para>

    <programlisting language="java">/**
 * The {@link HttpServer} addon interface, responsible for adding
 * features like WebSockets, Comet to HttpServer.
 */
public interface AddOn {
    /**
     * The method, which will be invoked by {@link HttpServer} in order to
     * initialize the AddOn on the passed {@link NetworkListener}.
     * Most of the time the AddOn implementation will update the passed
     * {@link NetworkListener}'s {@link FilterChainBuilder} by adding custom
     * {@link Filter}(s), which implement AddOn's logic.
     * 
     * @param networkListener the {@link NetworkListener} the addon is being
     *          initialized on.
     * @param builder the {@link FilterChainBuilder},
     *          representing the {@link NetworkListener} logic.
     */
    public void setup(NetworkListener networkListener,
            FilterChainBuilder builder);
}</programlisting>

    <para>So basically custom AddOn should implement only one method, and most
    of the time AddOn just inserts a custom logic Filter into the given
    FilterChainBuilder. Here is example of WebSocketAddOn:<programlisting>/**
 * WebSockets {@link AddOn} for the {@link org.glassfish.grizzly.http.server.HttpServer}.
 */
public class WebSocketAddOn implements AddOn {

    @Override
    public void setup(final NetworkListener networkListener,
            final FilterChainBuilder builder) {

        // Get the index of HttpCodecFilter in the HttpServer filter chain
        final int httpCodecFilterIdx = builder.indexOfType(HttpCodecFilter.class);

        if (httpCodecFilterIdx &gt;= 0) {
            // Insert the WebSocketFilter right after HttpCodecFilter
            builder.add(httpCodecFilterIdx + 1, new WebSocketFilter());
        }
    }
}</programlisting></para>
  </section>

  <section xml:id="httpserverframework-samples">
    <title>Samples</title>

    <para>The following example is a composite showing both the suspend/resume
    as well as the NIO streams. First we'll show the server side. Note that
    the following code snippets are part of a single example that makes use
    nested classes.</para>

    <programlisting language="java" linenumbering="numbered" startinglinenumber="304">/**
 * This handler using non-blocking streams to read POST data and echo it
 * back to the client.
 */
private static class NonBlockingEchoHandler extends HttpHandler {


    // -------------------------------------------- Methods from HttpHandler


    @Override
    public void service(final Request request,
                        final Response response) throws Exception {

        final char[] buf = new char[128];
        final NIOReader in = request.getReader(false); // false argument puts the stream in non-blocking mode
        final NIOWriter out = response.getWriter();

        response.suspend();

        // If we don't have more data to read - onAllDataRead() will be called
         in.notifyAvailable(new ReadHandler() {

            @Override
            public void onDataAvailable() throws Exception {
                System.out.println("[onDataAvailable] length: " + in.readyData());
                in.notifyAvailable(this);
            }

            @Override
            public void onError(Throwable t) {
                System.out.println("[onError]" + t);
            }

            @Override
            public void onAllDataRead() throws Exception {
                System.out.println("[onAllDataRead] length: " + in.readyData());
                try {
                    echoAvailableData(in, out, buf);
                } finally {
                    try {
                        in.close();
                    } catch (IOException ignored) {
                    }

                    try {
                        out.close();
                    } catch (IOException ignored) {
                    }

                    response.resume();
                }
            }
        });

    }

    private void echoAvailableData(NIOReader in, NIOWriter out, char[] buf)
    throws IOException {
            
        while(in.isReady()) {
            int len = in.read(buf);
            out.write(buf, 0, len);
        }
    }

} // END NonBlockingEchoHandler</programlisting>

    <para>As can be gleened from the name of the class, this HttpHandler
    implementation simply echoes POST data back to the client.</para>

    <para>Let's cover the major points of this part of the example:</para>

    <itemizedlist>
      <listitem>
        <para>line 318 - Configures the stream for non-blocking use
        cases.</para>
      </listitem>

      <listitem>
        <para>lines 321 - Response is suspended. service() method will exit.
        ReadHandler implementation will be notified as data becomes
        available.</para>
      </listitem>

      <listitem>
        <para>line 327-330 - onDataAvailable callback invoked as data is
        received by the server</para>
      </listitem>

      <listitem>
        <para>lines 338-356 - onAllDataRead callback invoked when client has
        finished message. All content is read and echoed back to the
        client.</para>
      </listitem>
    </itemizedlist>

    <para>Now we need to create a server and install this HttpHandler:</para>

    <programlisting language="java" linenumbering="numbered"
                    startinglinenumber="108">public static void main(String[] args) {

    // create a basic server that listens on port 8080.
    final HttpServer server = HttpServer.createSimpleServer();

    final ServerConfiguration config = server.getServerConfiguration();

    // Map the path, /echo, to the NonBlockingEchoHandler
    config.addHttpHandler(new NonBlockingEchoHandler(), "/echo");

    try {
        server.start();
        Client client = new Client();
        client.run();
    } catch (IOException ioe) {
        LOGGER.log(Level.SEVERE, ioe.toString(), ioe);
    } finally {
        server.stop();
    }
}</programlisting>

    <para>This part of the example is pretty straight forward. Create the
    server, install the HttpHandler to service requests made to /echo, and
    start the server.</para>

    <para>The client code which will follow will be sending data slowly to
    exercise the non-blocking HttpHandler. The client code relies on the http
    module primitives, so there's a little more code here to get this part of
    the example going. Let's start with the client Filter that sends
    request.</para>

    <programlisting language="java" linenumbering="numbered"
                    startinglinenumber="199">private static final class ClientFilter extends BaseFilter {

            private static final String[] CONTENT = {
                "contentA-",
                "contentB-",
                "contentC-",
                "contentD"
            };

            private FutureImpl&lt;String&gt; future;

            private StringBuilder sb = new StringBuilder();

            // ---------------------------------------------------- Constructors


            private ClientFilter(FutureImpl&lt;String&gt; future) {
                this.future = future;                
            }


            // ----------------------------------------- Methods from BaseFilter


            @SuppressWarnings({"unchecked"})
            @Override
            public NextAction handleConnect(FilterChainContext ctx) throws IOException {
                System.out.println("\nClient connected!\n");

                HttpRequestPacket request = createRequest();
                System.out.println("Writing request:\n");
                System.out.println(request.toString());
                ctx.write(request); // write the request

                // for each of the content parts in CONTENT, wrap in a Buffer,
                // create the HttpContent to wrap the buffer and write the
                // content.
                MemoryManager mm = ctx.getConnection().getTransport().getMemoryManager();
                for (int i = 0, len = CONTENT.length; i &lt; len; i++) {
                    HttpContent.Builder contentBuilder = request.httpContentBuilder();
                    Buffer b = Buffers.wrap(mm, CONTENT[i]);
                    contentBuilder.content(b);
                    HttpContent content = contentBuilder.build();
                    System.out.println(b.toStringContent());
                    ctx.write(content);
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace(); 
                    }
                }

                // since the request created by createRequest() is chunked,
                // we need to write the trailer to signify the end of the
                // POST data
                ctx.write(request.httpTrailerBuilder().build());

                System.out.println("\n");

                return ctx.getStopAction(); // discontinue filter chain execution

            }


            @Override
            public NextAction handleRead(FilterChainContext ctx) throws IOException {

                HttpContent c = (HttpContent) ctx.getMessage();
                Buffer b = c.getContent();
                if (b.hasRemaining()) {
                    sb.append(b.toStringContent());
                }

                // Last content from the server, set the future result so
                // the client can display the result and gracefully exit.
                if (c.isLast()) {
                    future.result(sb.toString());
                }
                return ctx.getStopAction(); // discontinue filter chain execution

            }


            // ------------------------------------------------- Private Methods


            private HttpRequestPacket createRequest() {

                HttpRequestPacket.Builder builder = HttpRequestPacket.builder();
                builder.method("POST");
                builder.protocol("HTTP/1.1");
                builder.uri("/echo");
                builder.chunked(true);
                HttpRequestPacket packet = builder.build();
                packet.addHeader("Host", HOST + ':' + PORT);
                return packet;

            }

        }

    } // END Client</programlisting>

    <para>High level points about this code:</para>

    <itemizedlist>
      <listitem>
        <para>lines 226-261 - When the connection is established with the
        server, the handleConnect() method of this Filter will be invoked.
        When this happens we create a HttpRequestPacket, which contains only
        message part of a POST request. wThe request is then written.</para>

        <itemizedlist>
          <listitem>
            <para>lines 237-249 writes the body of the message in 2 second
            intervals.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>line 255 - Write the trailer to signify the end of the request
        since the chunked transfer encoding is being used.</para>
      </listitem>

      <listitem>
        <para>lines 265-280 - Read the response from the server. Store the
        final result in a future to be retrieved later.</para>
      </listitem>
    </itemizedlist>

    <para>Lastly we need to define a client that utilizes the Filter that was
    just described:</para>

    <programlisting language="java" linenumbering="numbered"
                    startinglinenumber="133">private static final class Client {

    private static final String HOST = "localhost";
    private static final int PORT = 8080;

    public void run() throws IOException {
        final FutureImpl&lt;String&gt; completeFuture = SafeFutureImpl.create();

        // Build HTTP client filter chain
        FilterChainBuilder clientFilterChainBuilder = FilterChainBuilder.stateless();
        // Add transport filter
        clientFilterChainBuilder.add(new TransportFilter());

        // Add HttpClientFilter, which transforms Buffer &lt;-&gt; HttpContent
        clientFilterChainBuilder.add(new HttpClientFilter());
        // Add ClientFilter
        clientFilterChainBuilder.add(new ClientFilter(completeFuture));


        // Initialize Transport
        final TCPNIOTransport transport =
               TCPNIOTransportBuilder.newInstance().build();
        // Set filterchain as a Transport Processor
        transport.setProcessor(clientFilterChainBuilder.build());

        try {
            // start the transport
            transport.start();

            Connection connection = null;

            // Connecting to a remote Web server
            Future&lt;Connection&gt; connectFuture = transport.connect(HOST, PORT);
            try {
                // Wait until the client connect operation will be completed
                // Once connection has been established, the POST will
                // be sent to the server.
                connection = connectFuture.get(10, TimeUnit.SECONDS);

                // Wait no longer than 30 seconds for the response from the
                // server to be complete.
                String result = completeFuture.get(30, TimeUnit.SECONDS);

                // Display the echoed content
                System.out.println("\nEchoed POST Data: " + result + '\n');
            } catch (Exception e) {
                if (connection == null) {
                    LOGGER.log(Level.WARNING, "Connection failed.  Server is not listening.");
                } else {
                    LOGGER.log(Level.WARNING, "Unexpected error communicating with the server.");
                }
            } finally {
                // Close the client connection
                if (connection != null) {
                    connection.close();
                }
            }
        } finally {
            // stop the transport
            transport.stop();
        }
    }</programlisting>

    <para>The comments within the Client code should be sufficient to explain
    what's going on here. When running the complete example the output will
    look something like:</para>

    <screen>Mar 17, 2011 4:00:57 PM org.glassfish.grizzly.http.server.NetworkListener start
INFO: Started listener bound to [0.0.0.0:8080]
Mar 17, 2011 4:00:57 PM org.glassfish.grizzly.http.server.HttpServer start
INFO: [HttpServer] Started.

Client connected!

Writing request:

HttpRequestPacket (
   method=POST
   url=/echo
   query=null
   protocol=HTTP/1.1
   content-length=-1
   headers=[
      Host=localhost:8080]
)
WRITE: contentA-
[onDataAvailable] length: 9

(delay 2 seconds)

WRITE: contentB-
[onDataAvailable] length: 18

(delay 2 seconds)

WRITE: contentC-
[onDataAvailable] length: 27

(delay 2 seconds)

WRITE: contentD
[onDataAvailable] length: 35

[onAllDataRead] length: 35

Echoed POST Data: contentA-contentB-contentC-contentD

Mar 17, 2011 4:01:05 PM org.glassfish.grizzly.http.server.NetworkListener stop
INFO: Stopped listener bound to [0.0.0.0:8080]</screen>

    <para>A quick note about the output above, the (delay 2 seconds) isn't
    actually output. It's been added to visualize the artificial delay added
    by the Filter used by the client.</para>

    <para>This example in its entirety is available within the samples
    section of the Grizzly @project.version@ repository.</para>
  </section>
</chapter>
