<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="filterchain-filters"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>FilterChain and Filters</title>

  <para>In the previous sections we mentioned the <emphasis
  role="italic">Processor</emphasis>, and its role - processing I/O events
  occurred on Grizzly <emphasis role="italic">Connection</emphasis>s. The
  <emphasis role="italic">FilterChain</emphasis> is the most useful type of
  <emphasis role="italic">Processor</emphasis> used in Grizzly.</para>

  <para><inlinemediaobject>
      <imageobject>
        <imagedata fileref="../images/coreframework/filterchain-diagram.svg"></imagedata>
      </imageobject>
    </inlinemediaobject></para>

  <para><emphasis role="italic">FilterChain</emphasis>, according to its name,
  is a chain of <emphasis role="italic">Filter</emphasis>s. Each <emphasis
  role="italic">Filter</emphasis> represents a unit of processing work to be
  performed, whose purpose is to examine and/or modify the state of the
  transaction that is represented by a <emphasis
  role="italic">FilterChainContext</emphasis>.</para>

  <para>To give an idea how <emphasis role="italic">FilterChain</emphasis> may
  look like, here is example of <emphasis
  role="italic">FilterChain</emphasis>, which implements HTTP server
  logic:</para>

  <para><inlinemediaobject>
      <imageobject>
        <imagedata fileref="../images/coreframework/http-filterchain.svg"></imagedata>
      </imageobject>
    </inlinemediaobject></para>

  <para><itemizedlist>
      <listitem>
        <para>TransportFilter is responsible to read data from network
        <emphasis role="italic">Connection</emphasis> to a <emphasis
        role="italic">Buffer</emphasis>, and to write data from <emphasis
        role="italic">Buffer</emphasis> to a nework <emphasis
        role="italic">Connection</emphasis></para>
      </listitem>

      <listitem>
        <para>HttpFilter is responsible for <emphasis
        role="italic">Buffer</emphasis> &lt;-&gt; <emphasis
        role="italic">HttpPacket</emphasis> transformation (both
        directions)</para>
      </listitem>

      <listitem>
        <para>HttpServerFilter is responsible for processing request <emphasis
        role="italic">HttpPacket</emphasis>s and generating response <emphasis
        role="italic">HttpPacket</emphasis>s and send them back on <emphasis
        role="italic">FilterChain</emphasis> in opposite direction
        (HttpServerFilter-&gt;HttpFilter-&gt;TransportFilter).</para>
      </listitem>
    </itemizedlist></para>

  <para>So, what if we want to implement HTTPS server? It's simple:</para>

  <para><inlinemediaobject>
      <imageobject>
        <imagedata fileref="../images/coreframework/https-filterchain.svg"></imagedata>
      </imageobject>
    </inlinemediaobject></para>

  <para>we add just one SSLFilter, responsible for encoding/decoding SSL
  secured data.</para>

  <para>As we see, during the processing of any I/O Event, Filters in a
  FilterChain will be executed in the certain order. <emphasis
  role="bold">It's important to remember that the most of I/O Events are
  processed starting from first filter to last (from left to right on the
  schema above), except WRITE event, whose processing starts from last Filter
  in chain to first (from right to left a the schema above).</emphasis></para>

  <para>Let's define some <emphasis role="bold">terminology</emphasis> to make
  the following descriptions clearer:<itemizedlist>
      <listitem>
        <para><emphasis role="bold">Upstream</emphasis> - direction from this
        Filter to the last Filter in chain (from left to right on the schema
        above);</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Downstream</emphasis> - direction from
        this Filter to the first Filter in chain (from right to left on the
        schema above);</para>
      </listitem>
    </itemizedlist></para>

  <para>Let's take a look which I/O events could be processed by a <emphasis
  role="italic">FilterChain</emphasis>, for that purpose we can just take a
  look at the <emphasis role="italic">Filter</emphasis> interface
  methods:<programlisting>public NextAction handleRead(FilterChainContext ctx) throws IOException;

public NextAction handleWrite(FilterChainContext ctx) throws IOException;

public NextAction handleConnect(FilterChainContext ctx) throws IOException;

public NextAction handleAccept(FilterChainContext ctx) throws IOException;

public NextAction handleClose(FilterChainContext ctx) throws IOException;</programlisting></para>

  <para>so I/O events are<itemizedlist>
      <listitem>
        <para>READ: data is available from a Connection, which could be read
        and processed;</para>
      </listitem>

      <listitem>
        <para>WRITE: data is going to be written to a Connection and the
        Filter might be responsible to transform data representation form,
        like <emphasis role="italic">HttpPacket</emphasis> -&gt; <emphasis
        role="italic">Buffer</emphasis> on schema above;</para>
      </listitem>

      <listitem>
        <para>CONNECT: new client <emphasis
        role="italic">Connection</emphasis> has been connected;</para>
      </listitem>

      <listitem>
        <para>ACCEPT (TCP only): new client <emphasis
        role="italic">Connection</emphasis> has been accepted by server
        <emphasis role="italic">Connection</emphasis> (<emphasis
        role="italic">TCPNIOServerConnection</emphasis>);</para>
      </listitem>

      <listitem>
        <para>CLOSE: the Connection has been closed (either locally or by
        peer);</para>
      </listitem>
    </itemizedlist></para>

  <para><emphasis role="bold" xml:id="fc-serial-rule">It's important to
  remember that the same I/O events on the specific Connection are processed
  serially. For example, if we process READ I/O event on Connection "A",
  Grizzly will never start the processing of another READ I/O event on the
  same Connection "A", until previous processing won't be finished, or user
  won't explicitly do that in his code. If the latter - it's becoming
  responsibility of user to follow the rule of I/O events processing
  seriality</emphasis></para>

  <para>Additionally FilterChain Filters are able to initiate and handle
  custom event notifications. The event initiator may chose to emit the event
  upstream or downstream by FilterChain like:<programlisting>public NextAction handleRead(FilterChainContext ctx) throws IOException {
        // Here we decide to notify downstream Filters
        ctx.notifyDownstream(new MyEvent(...));

        // Notify upstream Filters
        ctx.notifyUpstream(new AnotherEvent(...));
}</programlisting></para>

  <para>The Filters in FilterChain are able to intercept and process custom
  Events by implementing method:<programlisting>public NextAction handleEvent(FilterChainContext ctx, FilterChainEvent event) throws IOException;</programlisting></para>

  <para>As we see each Filter "handle" method has FilterChainContext parameter
  and returns NextAction result.</para>

  <para><itemizedlist>
      <listitem>
        <para><emphasis role="bold">FilterChainContext</emphasis></para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="../images/coreframework/filterchaincontext.svg"></imagedata>
            </imageobject>
          </inlinemediaobject></para>

        <para>FilterChainContext represents a context (state), associated with
        processing of specific I/O event on the specific Connection, so its
        lifecycle is bound to the processing of a single I/O event.</para>

        <para>FilterChainContext contains following state
        information:<itemizedlist>
            <listitem>
              <para><emphasis role="bold">Connection</emphasis></para>

              <para>The Connection I/O event occurred on;</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Address</emphasis></para>

              <para>The peer address. In most cases it returns the same value
              as <emphasis
              role="italic">Connection.getPeerAddress()</emphasis>, except in
              the case when we handle a READ event on unbound UDP Connection.
              In this case, the <emphasis
              role="italic">FilterChainContext.getAddress()</emphasis> will
              return the address of peer, which sent data;</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Message</emphasis></para>

              <para>The message being processed. This is the only value
              Filters may change during the I/O event processing. Usually it
              is used during the incoming/outgoing message
              parsing/serializing. Each Filter is able to take initial message
              data, transform it to a different representation, set it back
              and pass processing to the next Filter in chain.</para>

              <para>For example, when handling READ event, HttpFilter gets
              message from FilterChainContext as Grizzly Buffer, transforms it
              to a HttpPacket, sets HttpPacket back to FilterChainContext
              message and passes control to a HttpServerFilter, which will get
              HttpPacket from the FilterChainContext and process it.</para>
            </listitem>
          </itemizedlist></para>

        <para>In addition to holding the state, the FilterChainContext
        provides support for commonly used I/O operations:<itemizedlist>
            <listitem>
              <para><emphasis role="bold">Read</emphasis></para>

              <para><programlisting>ReadResult readResult = ctx.read();</programlisting></para>

              <para>This operation performs a blocking FilterChain read
              starting at the first Filter in chain (inclusive) upstream to
              this Filter (exlusive).</para>

              <para>The operation will return a result, when processing of
              READ I/O event will reach the current Filter and FilterChain
              will be about to call handleRead(...) operation of this
              Filter.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Write</emphasis><programlisting>ctx.write(message);

or

ctx.write(message, completionHandler);

or

ctx.write(address, message, completionHandler);  // Unbound UDP only</programlisting></para>

              <para>This operation performs a non-blocking FilterChain write
              starting at this Filter (exclusive) downstream to the first
              Filter (inclusive). This operation initiates processing of WRITE
              I/O event on the FilterChain starting from this Filter
              (exclusive).</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Flush</emphasis><programlisting>ctx.flush();

or

ctx.flush(completionHandler);</programlisting></para>

              <para>This operation initializes and notifies downstream filters
              about special <emphasis
              role="italic">TransportFilter.FlushEvent</emphasis> so each
              Filter is able to handle this event and make sure all the cached
              data was written on the Connection.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Event
              notification</emphasis><programlisting>ctx.notifyUpstream(event);

or

ctx.notifyDownstream(event);</programlisting></para>

              <para>This operation notifies all the upstream/downstream
              Filters in the FilterChain about specific <emphasis
              role="italic">FilterChainEvent</emphasis>.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">NextAction</emphasis></para>

        <para>As stated previously, during processing of an I/O Event, the
        FilterChain is calling Filters one by one from first to last except
        WRITE event, which is being processed from last Filter to first. At
        the same time Filters can change the default I/O Event processing
        order by returning different types of NextAction:<itemizedlist>
            <listitem>
              <para><emphasis role="bold">InvokeAction</emphasis></para>

              <para><programlisting>return ctx.getInvokeAction();</programlisting></para>

              <para>instructs the FilterChain to run next Filter in chain
              according to the natural execution order.</para>

              <para>It's possible to create the InvokeAction with a remainder
              parameter:</para>

              <para><programlisting>return ctx.getInvokeAction(remainder);</programlisting></para>

              <para>this instructs the FilterChain to store the remainder and
              continue FilterChain execution like it was with
              non-parameterized version. Once the FilterChain execution
              completes, the remainder of the most recent Filter in chain will
              be restored FilterChain processing will be re-initialed starting
              from the Filter which stored the remainder.</para>

              <para>This feature is particularly useful for those cases a
              message is parsed from the source Buffer and discover that the
              Buffer contains several messages. This allows the developer to
              extract the first message and save the remainder to be processed
              after the current message processing has been completed.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">StopAction</emphasis></para>

              <para><programlisting>return ctx.getStopAction();</programlisting></para>

              <para>instructs the FilterChain to stop the processing of this
              I/O Event. Usually StopAction is returned when there isn't
              enough data to continue FilterChain processing, or it's the last
              Filter in the chain.</para>

              <para>Like InvokeAction, StopAction also could be
              parameterized<programlisting>return ctx.getStopAction(remainder);

or

return ctx.getStopAction(remainder, appender);</programlisting></para>

              <para>A remainder in StopAction means there isn't enough data to
              continue FilterChain processing. As more data becomes available
              but before FilterChain calls the Filter, it will check if the
              Filter has any data stored after the last invocation. If a
              remainder is present it will append the new data to the stored
              one and pass the result as the FilterChainContext
              message.</para>

              <para>Unlike remainder in the InvokeAction, the StopAction
              remainder should be "appendable", sothe FilterChain will know
              how new data chunk should be appended to the stored one. So the
              remainder should either implement <emphasis
              role="italic">org.glassfish.grizzly.Appendable</emphasis> or
              <emphasis
              role="italic">org.glassfish.grizzly.Appender</emphasis> should
              be passed as additional parameter.</para>
            </listitem>

            <listitem>
              <para><emphasis
              role="bold">RerunFilterAction</emphasis><programlisting>return ctx.getRerunFilterAction();</programlisting></para>

              <para>Instructs the FilterChain to re-run this Filter one more
              time. This can useful to simplify I/O event processing code and
              avoid recursions.</para>
            </listitem>

            <listitem xml:id="suspend-action">
              <para><emphasis role="bold">SuspendAction</emphasis></para>

              <programlisting>return ctx.getSuspendAction();</programlisting>

              <para>Instructs the FilterChain to terminate (leave) the I/O
              event processing in the current thread. The user will be able to
              resume the I/O event processing by calling<programlisting>ctx.resume();</programlisting></para>

              <para>Once <emphasis role="italic">ctx.resume()</emphasis> is
              called, FilterChain resumes processing at the same Filter it was
              suspended.</para>

              <para>Please note, after returning SuspendAction and before I/O
              event processing will be resumed, Grizzly <link
              linkend="fc-serial-rule">won't initialize</link> the same I/O
              event processing on the same Connection. For example if we
              return the SuspendAction during READ event processing - Grizzly
              won't notify the FilterChain about any new data coming on the
              same Connection, until READ event of the suspended event has
              been completed.</para>
            </listitem>

            <listitem>
              <para><emphasis
              role="bold">SuspendStopAction</emphasis><programlisting>return ctx.getSuspendStopAction();</programlisting></para>

              <para>This NextAction is very similar to <link
              linkend="suspend-action">SuspendAction</link>, except for one
              important thing. After getting SuspendStopAction, Grizzly will
              keep listening for the same I/O events on the Connection and
              notify FilterChain if they occur.</para>

              <para>Special care should be taken with this NextAction to make
              sure two or more threads are not processing the same I/O
              operation simultaneously.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist></para>
</section>
