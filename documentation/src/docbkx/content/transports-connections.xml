<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>Transports and Connections</title>
  <para>Transport and Connection represent core network API in Grizzly 2.0.</para>
    <para>Transport defines a network transport such as TCP or UDP including associated resources
        (thread-pool, memory manager etc) and default configuration for nested Connections.</para>
    <para>Connection in Grizzly 2.0 is a unit, which represents a single network connection (very
        similar to socket), depending on type of Transport it could be TCP or UDP connection or any
        custom connection type.</para>
    <para>The relationship between Transport and Connection is 1-to-many.</para>
    <para>
        <itemizedlist>
            <listitem>
                <para>Transports</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../images/coreframework/transport-diagram.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>As we see on the class diagram above, Grizzly 2.0 has two Transport
                    implementations: NIO TCP and NIO UDP, which is based on Java NIO, though in
                    perspective we're planning to add NIO.2 based transports and add SCTP support,
                    which will come in JDK 7.</para>
                <para>Let's briefly go throw the auxiliary components mentioned on the diagram<itemizedlist>
                        <listitem>
                            <para>MemoryManager implements the memory allocation/release logic (see
                                the <link linkend="memory">Memory managment</link> section);</para>
                        </listitem>
                        <listitem>
                            <para>ExecutorService represents the Transport associated
                                thread-pool</para>
                        </listitem>
                        <listitem>
                            <para>Processor transport default Processor logic, which is responsible
                                for processing NIO events. Processors are assigned per Connection,
                                so this one will be taken as the default one, but each Connection
                                may have own customized Processor</para>
                        </listitem>
                        <listitem>
                            <para>Strategy implements the Strategy (see <link linkend="iostrategies">I/O Strategies</link>
                                section)</para>
                        </listitem>
                        <listitem>
                            <para>NIOChannelDistributor is responsible for distributing newly
                                created Connections among Transport NIO Selector threads</para>
                        </listitem>
                        <listitem>
                            <para>SelectorRunner implements single Selector thread logic, which
                                selects ready NIO events and passes them to the Processor, which
                                will process it according to the Strategy logic</para>
                        </listitem>
                        <listitem>
                            <para>SelectionKeyHandler is a wrapper over SelectionKey operations, also<itemizedlist>
                                    <listitem>
                                        <para>maps Java NIO operations (OP_READ, OP_WRITE etc)
                                            mapping to Grizzly IOEvent</para>
                                    </listitem>
                                    <listitem>
                                        <para>maps Java NIO SelectionKey to Grizzly
                                            Connection</para>
                                    </listitem>
                                </itemizedlist></para>
                        </listitem>
                        <listitem>
                            <para>SelectorHandler implements thread-safe logic for
                                registering/deregistering SelectableChannels on Selectors, changing
                                SelectionKey interests, executing custom tasks in Selector threads
                                (to avoid unexpected locks)</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
            <listitem>
                <para>Connections</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../images/coreframework/connection-diagram.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>On the diagram above we see how Connections are related to Transports and
                    basic Connection abstractions. In Grizzly 2.0 we have TCP and UDP Connection
                    realization, besides that we have special server-Connections for both TCP and UDP.<itemizedlist>
                        <listitem>
                            <para>TCPNIOServerConnection works similar way as TCP ServerSocket. It
                                is bound to the specific TCP host:port and listens for the incoming
                                client side TCP connections. When new TCP connection is ready to be
                                accepted, TCPNIOServerConnection accepts it and taking into account
                                Transport settings it configures new connection accordingly.</para>
                        </listitem>
                        <listitem>
                            <para>UDPNIOServerConnection represents just UDP connection, which is
                                not bound to any specific peer address, so it's able to receive all
                                the UDP packets targeted to its UDP host:port. In other words the
                                only difference between UDPNIOConnection and UDPNIOServerConnection
                                is that the later is not bound to any peer address.</para>
                        </listitem>
                    </itemizedlist></para>
                <para> Let's briefly describe the rest of the components on the diagram above:<itemizedlist>
                        <listitem>
                            <para>Processor. The logic, which is responsible for processing
                                Connection NIO events (ACCEPT, CONNECT, READ, WRITE, CLOSE)</para>
                        </listitem>
                        <listitem>
                            <para>SelectionKey. The Connection underyling
                                java.nio.channels.SelectionKey, which defines the NIO
                                SelectableChannel &lt;-> Selector registration.</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
            <listitem>
                <para>Establishing client connections</para>
                <para>The ConnectorHandler API is reponsible for establishing and initializing
                    client connections.</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata
                                fileref="../images/coreframework/connectorhandler-diagram.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>As we see from the diagram above, TCPNIOTransport and UDPNIOTransport
                    implement interface SocketConnectorHandler, so it's possible to create a new
                    client Connection using Transport instance directly
                    like:<programlisting>Future&lt;Connection> clientConnectionFuture = tcpNioTransport.connect("grizzly.java.net", 80);
Connection clientConnection = clientConnectionFuture.get();</programlisting></para>
                <para>In this case newly create client Connection will derive Transport's Processor.
                    Or it's possible to create customized ConnectorHandler (similar for UDP and TCP
                    transports)
                    like:<programlisting>SocketConnectorHandler customUdpConnectorHandler = UDPNIOConnectorHandler.builder(udpNioTransport)
                             .processor(customFilterChain)
                             .build();
Future&lt;Connection> clientConnectionFuture = customUdpConnectorHandler.connect("timeserver.com", 3333);
Connection clientConnection = clientConnectionFuture.get();</programlisting></para>
                <para>We can describe the asynchronous connect operation as the sequence diagram,
                    actually two sequence diagrams :)</para>
                <para>The first one shows the steps passed in the current thread, where we call
                        <emphasis role="italic">ConnectorHandler.connect(...)</emphasis> operation
                    and get <emphasis role="italic">Future&lt;Connection></emphasis> as the
                    result:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../images/coreframework/connectorhandler-seq1.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>So the above code just adds the connection object on the <emphasis
                        role="italic">SelectorRunner</emphasis>'s queue, which is being processed
                    from selector-thread. Within the selector-thread the connection will be actually
                    registered on the <emphasis role="italic">SelectorRunner</emphasis>'s associated
                    Selector and, once it happened, the <emphasis role="italic"
                        >SelectorRunner</emphasis> notifies <emphasis role="italic"
                        >ConnectorHandler</emphasis> about the registration completion and<itemizedlist>
                        <listitem>
                            <para>for UDP transport - <emphasis role="italic"
                                    >UDPNIOConnection</emphasis> is getting initilized, the
                                    <emphasis role="italic">Processor</emphasis> gets notified about
                                CONNECT operation completion and finally the <emphasis role="italic"
                                    >Future&lt;Connection></emphasis> result becomes available in
                                the custom-thread;</para>
                        </listitem>
                        <listitem>
                            <para>for TCP transport - we still wait until underlying OS network
                                framework will notify us that the connection was actually connected
                                to the destination address (UDP doesn't have this) and only then
                                    <emphasis role="italic">Processor</emphasis> gets notified about
                                CONNECT operation completion and finally the <emphasis role="italic"
                                    >Future&lt;Connection></emphasis> result becomes available in
                                the custom-thread;</para>
                        </listitem>
                    </itemizedlist></para>
                <para>In general the logic looks like:</para>
                <para><inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../images/coreframework/connectorhandler-seq2.svg"/>
                        </imageobject>
                    </inlinemediaobject></para>
                <para>Talking about TCP transport, we have to mention the usecase, when we're on the
                    server side and <emphasis role="italic">TCPNIOServerConnection</emphasis>
                    accepts new client connection. In this case the processing logic looks pretty
                    much like on the diagram above, but instead of "CONNECT", we notify <emphasis
                        role="italic">Processor</emphasis> about "ACCEPT" event occurred on the
                        <emphasis role="italic">TCPNIOConnection</emphasis>.</para>
            </listitem>
        </itemizedlist>
    </para>
</section>
