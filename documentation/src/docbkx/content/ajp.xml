<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011-2012 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter version="5.0" xml:id="ajp" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
  <title>AJP</title>

  <section xml:id="ajp-overview">
    <title>Overview</title>

    <para>Starting with version 2.1, Grizzly supports <link
    xlink:href="http://en.wikipedia.org/wiki/Apache_JServ_Protocol">AJP</link>
    1.3 (Apache JServ Protocol) natively. "Natively" means AJP is implemented
    using core Grizzly APIs and naturally fits into entire Grizzly
    infrastructure: memory management, threading etc...</para>
  </section>

  <section xml:id="ajp-workings">
    <title>How it works</title>

    <para>The AJP protocol implementation is mainly represented by two
    Filters: AjpMessageFilter, AjpHandlerFilter. The AjpMessageFilter is
    responsible for constructing AJP protocol messages and AjpHandlerFilter
    contains the actual processing logic, which works as a codec between AJP
    and HTTP messages. All the Filters upstream to AjpHandlerFilter receive
    HTTP messages for processing, so they are not even aware of AJP
    protocol.</para>

    <para>Here is a FilterChain, which is being normally constructed, when
    Grizzly HttpServer being used:</para>

    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="../images/ajp/httpserver-filterchain.png"/>
        </imageobject>
      </inlinemediaobject></para>

    <para>Now, what happens, if we want to use AJP? It's easy, we replace HTTP
    Filter, which works as a codec for Buffer &lt;-&gt; HTTP transformation,
    with the two Filters mentioned above: AjpMessageFilter and
    AjpHandlerFilter:</para>

    <para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="../images/ajp/httpserver-ajp-filterchain.png"/>
        </imageobject>
      </inlinemediaobject></para>

    <para>So the Grizzly HttpServer Filter won't even notice it operates over
    AJP rather than plain HTTP.</para>

    <para>In order to simplify HttpServer AJP configuration, there is an
    AjpAddOn available, which may be registered on the required HttpServer's
    NetworkListener like:</para>

    <programlisting language="java">HttpServer httpServer = new HttpServer();
NetworkListener listener =
         new NetworkListener("grizzly",
         NetworkListener.DEFAULT_NETWORK_HOST, PORT);

AjpAddOn ajpAddon = new AjpAddOn();
listener.registerAddOn(ajpAddon);
        
        httpServer.addListener(listener);</programlisting>
  </section>

  <section xml:id="ajp-config">
    <title>AJP Configuration</title>

    <table>
      <title>AjpHandlerFilter and AjpAddOn Properties</title>

      <tgroup cols="2">
        <tbody>
          <row>
            <entry>isTomcatAuthentication</entry>

            <entry>If set to true, the authentication will be done in Grizzly.
            Otherwise, the authenticated principal will be propagated from the
            native webserver and used for authorization in Grizzly. The
            default value is true.</entry>
          </row>

          <row>
            <entry>secret</entry>

            <entry>If not null, only requests from workers with this secret
            keyword will be accepted, null means no secret check will be
            done.</entry>
          </row>

          <row>
            <entry>shutdownHandlers</entry>

            <entry>The set of ShutdownHandlers, which will be invoked, when
            AJP shutdown request received. The implementation itself doesn't
            perform any action related to shutdown request.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section xml:id="ajp-samples">
    <title>Sample</title>

    <para>There is a simple AJP "Hello World" sample available, which contains
    a single class, single HttpHandler, which is accessable via AJP and HTTP
    at the same time. Here is the most interesting part of it responsible for
    HttpServer initialization.</para>

    <programlisting language="java">        final HttpServer server = new HttpServer();

        // Create plain HTTP listener, which will handle port 8080
        final NetworkListener httpNetworkListener =
                new NetworkListener("http-listener", "0.0.0.0", 8080);

        // Create AJP listener, which will handle port 8009
        final NetworkListener ajpNetworkListener =
                new NetworkListener("ajp-listener", "0.0.0.0", 8009);
        // Register AJP addon on HttpServer's listener
        ajpNetworkListener.registerAddOn(new AjpAddOn());

        server.addListener(httpNetworkListener);
        server.addListener(ajpNetworkListener);

        final ServerConfiguration config = server.getServerConfiguration();

        // Map the path, /grizzly, to the HelloWorldHandler
        config.addHttpHandler(new HelloWorldHandler(), "/grizzly");</programlisting>

    <para>The <link
    xlink:href="http://java.net/projects/grizzly/sources/git/content/samples/http-ajp-samples/readme.txt?rev=c8ff8e24974f3c4be9a1833e58adf139b656a730">readme.txt</link>
    contains setup and run instructions.</para>

    <para>Complete sources and instructions could be found <link
    xlink:href="http://java.net/projects/grizzly/sources/git/show/samples/http-ajp-samples?rev=c8ff8e24974f3c4be9a1833e58adf139b656a730">here</link>.
    </para>
  </section>
</chapter>
