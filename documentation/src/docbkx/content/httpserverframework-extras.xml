<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<chapter xml:id="http-server-framework-extras" version="5.0" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:db="http://docbook.org/ns/docbook">
  <title>The HTTP Server Framework Extras</title>
  <para>The extra Grizzly 2.0 HTTP server framework features, provided by separate modules</para>

  <section>
    <title>Multipart (multipart/form-data) HTTP Requests Processing</title>

    <para>The file sharing became a very popular internet service, when users are able to upload
      files and share them for group of people. Regulary the way users may upload their files is
      regular HTML form
      like:<programlisting language="html">&lt;form action="upload" method="post" enctype="multipart/form-data">
  &lt;input type="text" name="description"/>
  &lt;input type="file" name="fileName"/>
  &lt;input type="submit" value="submit"/>
&lt;/form></programlisting></para>
    <para>which finally, after you press "submit" button will generate multipart HTTP request. For
      sample above, HTTP request will contain two parts: text description and chosen file content,
      like:<programlisting>POST /upload HTTP/1.1
Host: localhost:18080
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.7,uk;q=0.3
Content-Type: multipart/form-data; boundary=---------------------------78965753017082023611608934090
Content-Length: 357

-----------------------------78965753017082023611608934090
Content-Disposition: form-data; name="description"

some text file
-----------------------------78965753017082023611608934090
Content-Disposition: form-data; name="fileName"; filename="test.txt"
Content-Type: text/plain

TEST
-----------------------------78965753017082023611608934090-- </programlisting></para>
    <para>When using standard Grizzly http-server module, the content of the message above will
      be represented as one single message together with boundaries, so user will be responsible for
      parsing content himself or use  existing library, which usually processes multipart requests
      in a blocking way.</para>
    <para>Grizzly http-server-multipart module provides API, which simplifies multipart HTTP
      requests processing asynchronously in non-blocking way. Basically it's represented by
      MultipartScanner, containing two "scan" methods:<itemizedlist>
        <listitem>
          <para>Top level multipart HTTP request scanner (multipart/form-data)</para>
          <programlisting language="java">public static void scan(final Request request,
        final MultipartEntryHandler partHandler,
        final CompletionHandler&lt;Request> completionHandler);</programlisting>
        </listitem>
        <listitem>
          <para>multipart/mixed entries
            scanner<programlisting language="java">public static void scan(final MultipartEntry multipartMixedEntry,
        final MultipartEntryHandler partHandler,
        final CompletionHandler&lt;MultipartEntry> completionHandler);</programlisting></para>
        </listitem>
        
      </itemizedlist></para>
    <para>By calling one of the methods above we initialize asynchronous multipart request
      processing, which is going to be handled by passed MultipartEntryHandler (which is very
      similar to HttpHandler) and ultimately passed CompletionHandler will be notified about
      multipart HTTP request processing success or error.</para>
    <para>The MultipartEntryHandler API is very simple and looks very similar to
      HttpHandler:<programlisting language="java">/**
 * General interface for processing {@link MultipartEntry}s, one by one.
 * 
 * @since 2.0.1
 */
public interface MultipartEntryHandler {
    /**
     * The method is called once {@link MultipartEntry} header is ready to be
     * processed by user code.
     * 
     * @param part {@link MultipartEntry}
     * @throws Exception
     */
    public void handle(final MultipartEntry multipartEntry) throws Exception;
}</programlisting></para>
    <para>so inside the handle(...) method we're able to process the passed multipart entry,
      check its content type, disposition etc... and finally initialize the asynchronous
      non-blocking processing of entry's content using either NIOInputStream (binary mode) or
      NIOReader (text mode) API described in the http-server <link linkend="hsf-nio-streams">section</link><programlisting language="java">NIOInputStream nioInputStream = multipartEntry.getNIOInputStream();</programlisting></para>
    <para>or<programlisting language="java">NIOReader nioReader = multipartEntry.getNIOReader();</programlisting></para>
    <para>Please note, unlike the NIOInputStream and NIOReader got from HTTP Request, the ones
      got out of MultipartEntry would have content of a single multipart entry and report end of
      stream once end of multipart entry is reached.</para>
    <para>Also it's important to understand that multipart message processing is asynchronous so
      we have to suspend HTTP request processing before starting the scanning and don't forget to
      resume the HTTP request processing inside the passed CompletionHandler. See http-server
      <link linkend="hsf-suspend-resume">section</link> for more information on HTTP request suspend/resume.</para>
    <section>
      <title>Dependencies</title>
      <para>Maven developers require a dependency on the http-server-multipart module. The following
        dependency needs to be added to the
        pom:<programlisting language="xml">&lt;dependency&gt;
     &lt;groupId&gt;org.glassfish.grizzly&lt;/groupId&gt;
     &lt;artifactId&gt;grizzly-http-server-multipart&lt;/artifactId&gt;
     &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;</programlisting></para>
      
      <para>Non-maven developers, additionally to jars, required by <link
        linkend="http-server-dep">HTTP Server framework</link>,
        require:<itemizedlist>
          <listitem>
            <para><link
                xlink:href="http://download.java.net/maven/glassfish/org/glassfish/grizzly/grizzly-http-servlet/2.0.1/grizzly-http-server-multipart-2.0.1.jar"
                >grizzly-http-server-multipart.jar</link></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Sample</title>
      <para>Let's see how the file-uploader implementation may look like.</para>
      <para>First of all let's create HttpHandler, which would be responsible for multipart HTTP
        requests
        processing<programlisting language="java">public class UploaderHttpHandler extends HttpHandler {
    private static final String DESCRIPTION_NAME = "description";
    private static final String FILENAME_ENTRY = "fileName";

    // uploads counter (just for debugging/tracking reasons)
    private final AtomicInteger uploadsCounter = new AtomicInteger(1);

    /**
     * Service HTTP request.
     */
    @Override
    public void service(final Request request, final Response response)
            throws Exception {
        
        // Suspend the HTTP request processing
        // (in other words switch to asynchronous HTTP processing mode).
        response.suspend();

        // assign uploadNumber for this specific upload
        final int uploadNumber = uploadsCounter.getAndIncrement();

        // Initialize MultipartEntryHandler, responsible for handling
        // multipart entries of this request
        final UploaderMultipartHandler uploader =
                new UploaderMultipartHandler(uploadNumber);

        // Start the asynchronous multipart request scanning...
        MultipartScanner.scan(request,
                uploader,
                new EmptyCompletionHandler&lt;Request>() {
            // CompletionHandler is called once HTTP request processing is completed
            // or failed.
            @Override
            public void completed(final Request request) {
                // Upload is complete
                final int bytesUploaded = uploader.getBytesUploaded();
                
                // Compose a server response.
                try {
                    response.setContentType("text/plain");
                    final Writer writer = response.getWriter();
                    writer.write("Completed. " + bytesUploaded + " bytes uploaded.");
                } catch (IOException ignored) {
                }

                // Resume the asychronous HTTP request processing
                // (in other words finish the asynchronous HTTP request processing).
                response.resume();
            }

            @Override
            public void failed(Throwable throwable) {
                // Complete the asynchronous HTTP request processing.
                response.resume();
            }
        });
    }
}</programlisting></para>
      <para>the important part in the code is calls to response.suspend() before starting the
        multipart request scanning and response.resume() once multipart HTTP request is
        processed.</para>
      <para>Now we're ready to take a look at the UploaderMultipartHandler code, which is
        responsible for processing single multipart
        entries<programlisting language="java">    /**
     * {@link MultipartEntryHandler}, responsible for processing the upload.
     */
    private final class UploaderMultipartHandler
            implements MultipartEntryHandler {
        
        // upload number
        private final int uploadNumber;
        // number of bytes uploaded
        private final AtomicInteger uploadedBytesCounter = new AtomicInteger();
        
        public UploaderMultipartHandler(final int uploadNumber) {
            this.uploadNumber = uploadNumber;
        }
        
        /**
         * {@inheritDoc}
         */
        @Override
        public void handle(final MultipartEntry multipartEntry) throws Exception {
            // get the entry's Content-Disposition
            final ContentDisposition contentDisposition =
                    multipartEntry.getContentDisposition();
            // get the multipart entry name
            final String name = contentDisposition.getDispositionParamUnquoted("name");

            // if the multipart entry contains a file content
            if (FILENAME_ENTRY.equals(name)) {

                // get the filename for Content-Disposition
                final String filename =
                        contentDisposition.getDispositionParamUnquoted("filename");

                // Get the NIOInputStream to read the multipart entry content
                final NIOInputStream inputStream = multipartEntry.getNIOInputStream();

                // start asynchronous non-blocking content read.
                inputStream.notifyAvailable(
                        new UploadReadHandler(uploadNumber, filename,
                        inputStream, uploadedBytesCounter));

            } else if (DESCRIPTION_NAME.equals(name)) { // if multipart entry contains a description field
                // skip the multipart entry
                multipartEntry.skip();
            } else { // Unexpected entry?
                // skip it
                multipartEntry.skip();
            }
        }

        /**
         * Returns the number of bytes uploaded for this multipart entry.
         * 
         * @return the number of bytes uploaded for this multipart entry.
         */
        int getBytesUploaded() {
            return uploadedBytesCounter.get();
        }
    }</programlisting></para>
      <para>inside the handle(...) method we check if multipart entry represents a file to be
        uploaded, because as we mentioned in the beginning, the HTTP multipart request contains two
        multipart entries: one for description and second is actual file content. If multipart entry
        represents a text description - we just skip it by calling multipartEntry.skip(). However if
        multipart entry represents a file content - we start the asynchronous content reading using
        NIOInputStream.</para>
      <para>Let's see how our asynchronous ReadHandler looks
        like:<programlisting language="java">    /**
     * Simple {@link ReadHandler} implementation, which is reading HTTP request
     * content (uploading file) in non-blocking mode and saves the content into
     * the specific file.
     */
    private class UploadReadHandler implements ReadHandler {

        // the upload number
        private final int uploadNumber;
        // Non-blocking multipart entry input stream
        private final NIOInputStream inputStream;

        // the destination file output stream, where we save the data.
        private final FileOutputStream fileOutputStream;
        
        // temporary buffer
        private final byte[] buf;

        // uploaded bytes counter
        private final AtomicInteger uploadedBytesCounter;
        
        private UploadReadHandler(final int uploadNumber,
                final String filename,
                final NIOInputStream inputStream,
                final AtomicInteger uploadedBytesCounter)
                throws FileNotFoundException {

            this.uploadNumber = uploadNumber;
            fileOutputStream = new FileOutputStream(filename);
            this.inputStream = inputStream;
            this.uploadedBytesCounter = uploadedBytesCounter;
            buf = new byte[2048];
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void onDataAvailable() throws Exception {
            // save available file content
            readAndSaveAvail();

            // register this handler to be notified next time some data
            // becomes available
            inputStream.notifyAvailable(this);
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void onAllDataRead() throws Exception {
            // save available file content
            readAndSaveAvail();
            // finish the upload
            finish();
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void onError(Throwable t) {
            // finish the upload
            finish();
        }

        /**
         * Read available file content data out of HTTP request and save the
         * chunk into local file output stream
         * 
         * @throws IOException
         */
        private void readAndSaveAvail() throws IOException {
            while (inputStream.isReady()) {
                // read the available bytes from input stream
                final int readBytes = inputStream.read(buf);
                // update the counter
                uploadedBytesCounter.addAndGet(readBytes);
                // save the file content to the file
                fileOutputStream.write(buf, 0, readBytes);
            }
        }

        /**
         * Finish the file upload
         */
        private void finish() {
            try {
                // close file output stream
                fileOutputStream.close();
            } catch (IOException ignored) {
            }
        }
    }</programlisting></para>
      <para>As we see the logic is pretty simple, once ReadHandler is notified about some data
        being available - we read the data off the NIOInputStream and store it to a local file. If
        we expect more data - we just reregister the ReadHandler to wait for it, otherwise finish
        the upload by closing the local file output stream.</para>
      <para>The complete working sample could be downloaded <link
          xlink:href="http://download.java.net/maven/glassfish/org/glassfish/grizzly/samples/grizzly-http-multipart-samples/2.0.1/grizzly-http-multipart-samples-2.0.1-sources.jar"
          >here</link></para>
    </section>  
  </section>
</chapter>