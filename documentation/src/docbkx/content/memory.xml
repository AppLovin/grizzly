<?xml version="1.0" encoding="UTF-8"?>
<!--

    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

-->
<section version="5.0" xml:id="memory" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Memory Management</title>

  <section xml:id="mem-overview">
    <title>Overview</title>

    <para>Grizzly 2.0 introduces a new subsystem to improve memory management
    within the runtime. This subsystem is comprised of three main
    artifacts:</para>

    <itemizedlist>
      <listitem>
        <para>Buffers</para>
      </listitem>

      <listitem>
        <para>Thread local memory pools</para>
      </listitem>

      <listitem>
        <para>MemoryManager as a factory of sorts using the buffers and thread
        local pools</para>
      </listitem>
    </itemizedlist>

    <para>whose primary purpose is to speed up memory allocation and, when
    possible, provide for memory re-use.</para>

    <para>The following sections will describe these concepts in
    detail.</para>
  </section>

  <section xml:id="mem-manager">
    <title>MemoryManager</title>

    <para>The <emphasis>MemoryManager</emphasis> is the main interface for
    allocating/deallocating <emphasis>Buffer</emphasis> instances:</para>

    <programlisting language="java">public interface MemoryManager&lt;E extends Buffer>
        extends JmxMonitoringAware&lt;MemoryProbe> {

    /**
     * Allocated {@link Buffer} of the required size.
     *
     * @param size {@link Buffer} size to be allocated.
     * @return allocated {@link Buffer}.
     */
    public E allocate(int size);

    /**
     * Allocated {@link Buffer} at least of the provided size.
     * This could be useful for usecases like Socket.read(...), where
     * we're not sure how many bytes are available, but want to read as
     * much as possible.
     *
     * @param size the min {@link Buffer} size to be allocated.
     * @return allocated {@link Buffer}.
     */
    public E allocateAtLeast(int size);

    /**
     * Reallocate {@link Buffer} to a required size.
     * Implementation may choose the way, how reallocation could be done, either
     * by allocating new {@link Buffer} of required size and copying old
     * {@link Buffer} content there, or perform more complex logic related to
     * memory pooling etc.
     *
     * @param oldBuffer old {@link Buffer} to be reallocated.
     * @param newSize new {@link Buffer} required size.
     * @return reallocated {@link Buffer}.
     */
    public E reallocate(E oldBuffer, int newSize);

    /**
     * Release {@link Buffer}.
     * Implementation may ignore releasing and let JVM Garbage collector to take
     * care about the {@link Buffer}, or return {@link Buffer} to pool, in case
     * of more complex &lt;tt>MemoryManager&lt;/tt> implementation.
     *
     * @param buffer {@link Buffer} to be released.
     */
    public void release(E buffer);
    
    /**
     * Return &lt;tt>true&lt;/tt> if next {@link #allocate(int)} or {@link #allocateAtLeast(int)} call,
     * made in the current thread for the given memory size, going to return a {@link Buffer} based
     * on direct {@link java.nio.ByteBuffer}, or &lt;tt>false&lt;/tt> otherwise.
     * 
     * @param size
     * @return 
     */
    public boolean willAllocateDirect(int size);
}</programlisting>

    <para>There is typically a single <emphasis>MemoryManager</emphasis> servicing all transports
      defined within the Grizzly runtime. This <emphasis>MemoryManager</emphasis> can be obtained by
      referencing the static member of the MemoryManager interface:</para>

    <programlisting language="java">MemoryManager.DEFAULT_MEMORY_MANAGER</programlisting>

    <para>Conversely, custom <emphasis>MemoryManager</emphasis> implementations may be made as the
      default MemoryManager by defining the system property <emphasis role="italic"
        >org.glassfish.grizzly.DEFAULT_MEMORY_MANAGER</emphasis> that references the fully qualified
      class name of the MemoryManager implementation to use.  Note that this implementation must
      have a public no-arg constructor in order for the runtime to properly set the new
      default.</para>

    <para>Grizzly @project.version@ includes two <emphasis>MemoryManager</emphasis> implementations:
        <emphasis>HeapMemoryManager</emphasis> and <emphasis>ByteBufferManager</emphasis>. By
      default, the Grizzly runtime will use the <emphasis>HeapMemoryManager</emphasis>, however if a
      Grizzly application requires direct ByteBuffer access, then the
        <emphasis>ByteBufferManager</emphasis> can be used.</para>

    <section xml:id="mem-bytebufmm">
      <title>ByteBufferManager</title>

      <para>The <emphasis>ByteBufferManager</emphasis> implementation vends Grizzly Buffer instances
        that wrap JDK ByteBuffer instances.  This is the MemoryManager to use if the Grizzly
        application requires direct ByteBuffer usage.   </para>
      <para>It should be noted that this MemoryManager, during our benchmarking, showed to have a
        little more overhead when using typical heap buffers.  As such, if direct memory isn't
        needed, we recommend that the default HeapMemoryManager be used.</para>
    </section>

    <section xml:id="mem-heapmm">
      <title>HeapMemoryManager</title>

      <para>The HeapMemoryManager is the default MemoryManager.  Instead of wrapping ByteBuffer
        instances, this MemoryManager will allocate Buffer instances that wrap byte arrays directly.
        This MemoryManager offers better performance characteristics for operations such as trimming
        or splitting.  </para>
    </section>

    <section xml:id="mem-pools">
      <title>ThreadLocal Memory Pools</title>

      <para>ThreadLocal memory pools provide the ability to allocate memory
      without any synchronization costs. Both the
      <emphasis>ByteBufferManager</emphasis> and
      <emphasis>HeapMemoryManager</emphasis> use such pools. Note that it's
      not required that a custom <emphasis>MemoryManager</emphasis> use such
      pools, however, if said <emphasis>MemoryManager</emphasis> implements
      the <emphasis>ThreadLocalPoolProvider</emphasis> interface, then a
      <emphasis>ThreadLocalPool</emphasis> implementation must be provided.
      The <emphasis>ThreadLocalPool</emphasis> implementation will be created
      and passed to each thread being maintained by Grizzly's managed
      threads.</para>
    </section>

    <section xml:id="mem-mm-and-pools">
      <title>Memory Manager and ThreadLocal Memory Pools Working
      Together</title>

      <para>The following provides a flow diagram of how an allocation request
      to a <emphasis>MemoryManager</emphasis> with a
      <emphasis>ThreadLocalPool</emphasis> would typically work:</para>

      <figure>
        <title>MemoryManager Allocation Request Flow</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/coreframework/mmflow.png" scale="99"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section xml:id="mem-buffers">
    <title>Buffers</title>

    <para>Grizzly @project.version@ provides several buffers for developers to leverage when
    creating applications. These <emphasis>Buffer</emphasis> implementations
    offer features not available when using the JDK's ByteBuffer.</para>

    <section xml:id="mem-buffer">
      <title>Buffer</title>

      <para>The <emphasis>Buffer</emphasis> is essentially the analogue to the
      JDK's ByteBuffer. It offers the same set of methods for:</para>

      <itemizedlist>
        <listitem>
          <para>Pushing/pulling data to/from the
          <emphasis>Buffer</emphasis>.</para>
        </listitem>

        <listitem>
          <para>Methods for accessing or manipulating the
          <emphasis>Buffer's</emphasis> position, limit, and capacity.</para>
        </listitem>
      </itemizedlist>

      <para>In addition to offering familar semantics to ByteBuffer, the
      following features are available:</para>

      <itemizedlist>
        <listitem>
          <para>Splitting, trimming, and shrinking.</para>
        </listitem>

        <listitem>
          <para>Prepending another <emphasis>Buffer's</emphasis> content to
          the current Buffer.</para>
        </listitem>

        <listitem>
          <para>Converting the <emphasis>Buffer</emphasis> to a ByteBuffer or
          ByteBuffer[].</para>
        </listitem>

        <listitem>
          <para>Converting <emphasis>Buffer</emphasis> content to a
          String.</para>
        </listitem>
      </itemizedlist>

      <para>Please see the javadocs for further details on
      <emphasis>Buffer</emphasis>.</para>
    </section>

    <section xml:id="mem-comp-buffer">
      <title>CompositeBuffer</title>

      <para>The <emphasis>CompositeBuffer</emphasis> is another
      <emphasis>Buffer</emphasis> implementation which allows appending of
      <emphasis>Buffer</emphasis> instances. The CompositeBuffer maintains a
      virtual position, limit, and capacity based on the
      <emphasis>Buffers</emphasis> that have been appended and can be treated
      as a simple <emphasis>Buffer</emphasis> instance.</para>

      <para>Please see the javadocs for further details on
      <emphasis>CompositeBuffer</emphasis>.</para>
    </section>
  </section>
</section>
